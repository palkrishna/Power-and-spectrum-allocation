# -*- coding: utf-8 -*-
"""Krishna(mu=3).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y8Hz9xiCOm6DJl4aCJDOc3SwmFmGBdgX

Pathloss Model
"""

import numpy as np
from math import log10,sqrt,log2  
import scipy.stats
from random import randint
from openpyxl import workbook,load_workbook
def pathloss(linkType,f_c,d) :
  bsAntGain = 8             # BS antenna gain 8 dBi 
  bsNoiseFigure = 7         # BS noise figure 7 dB 
  d2dAntGain = 5            # vehicle antenna gain 5 dBi
  d2dNoiseFigure = 13       # vehicle noise figure 13 dB
  if ((linkType).upper== 'V2V') :                                                            
    if d<18:
       pathloss= 38.77 + 20 * log10(d) + 20 * log10(f_c)       # LOS pathloss
       PL_dB = -(np.random.randn()*3 + pathloss) + 2*d2dAntGain - d2dNoiseFigure 
    else :
       pathloss = 36.85 + 30 * log10(d) + 18.9 * log10(f_c)    # NLOS pathloss 
       PL_dB = -(np.random.randn()*4 + pathloss) + 2*d2dAntGain - d2dNoiseFigure
  
  else :
      pathloss =  32.4 + 20 * log10(f_c) + 27 * log10(d) 
      PL_dB = -(np.random.randn()*7.8 + pathloss) + d2dAntGain + bsAntGain - bsNoiseFigure 
  
  return PL_dB

"""User Initialization"""

def genDUE(numDUE):
  d2dPos = []          # initilizer for vehicle position
  indDUE = []
  indDUE2 = [] 
  pproc2 = []
  numLane = 4
  laneWidth = 4
  v = 50                   # velocity
  d_avg = 2.5*v/3.6         # average inter-vehicle distance according to TR 36.885
  radius = 500
  disBstoHwy = 25           # in meters
  d0 = sqrt(radius**2-disBstoHwy**2)
  ###### generate all d2d positions and store in d2dPos
  for ilane in range(numLane) :
    npoints = np.random.poisson(2*d0/d_avg)
    pproc = (np.random.randn(npoints)*2-1)*100                                      # horizontal coordinates
    for i in range(len(pproc)) :
      z=np.zeros((1,2))
      z[0,0] = pproc[i]
      z[0,1] = disBstoHwy+ilane*laneWidth
      pproc2.append(z)
  d2dPos = pproc2
  numd2d = len(d2dPos)

  indPerm = np.random.permutation(numd2d)
  indDUE = indPerm[0:numDUE]
  indDUE2 = np.zeros(numDUE)
  for ii in range(numDUE)  : 
    ######### pair each element in indDUE with closet vehicle and store the index in indDUE2  ##############
    minDist = 2*d0
    tmpInd = 0
    for iii in range(numd2d) :
        if (abs(iii-indDUE)<1e-6).any() or (abs(iii-indDUE2)<1e-6).any() :                       # iii in indDUE or indDUE2 
            continue
        newDist = sqrt((d2dPos[indDUE[ii]][0][0]-d2dPos[iii][0][0])**2 + (d2dPos[indDUE[ii]][0][1]-d2dPos[iii][0][1])**2)
        if newDist < minDist :
            tmpInd = iii
            minDist = newDist
    indDUE2[ii] = tmpInd                              # the closest DUE pair
  return d2dPos,indDUE,indDUE2

def genCUE(xMin,xMax,yMin,yMax,numCUE) :
  xDelta=xMax-xMin
  yDelta=yMax-yMin
  areaTotal=xDelta*yDelta
  lambda0=100
  numbPoints =scipy.stats.poisson( lambda0*areaTotal ).rvs()#Poisson number of points
  xx = xDelta*scipy.stats.uniform.rvs(0,1,((numbPoints,1)))+xMin#x coordinates of Poisson points
  yy = yDelta*scipy.stats.uniform.rvs(0,1,((numbPoints,1)))+yMin#y coordinates of Poisson points
  x = []
  y= []
  for i in range(numCUE) :
   x.append(xx[i])
   y.append(yy[i])
  return x,y

"""CQI SINR Mapping"""

################# For cellular user ###################
def CQICUE(SNR) :  
    if SNR < -6.5 :
        RB_all = 0
        return RB_all
    
    elif SNR < -4 :
        RB_all = 16
        return RB_all
    
    elif SNR < -2.6 :
        RB_all = 11
        return RB_all
    
    elif SNR < -1 :
        RB_all = 7
        return RB_all
    
    elif SNR < 1 :
        RB_all = 4
        return RB_all
    
    elif SNR < 6.6 :
        RB_all = 3
        return RB_all    
    
    elif SNR < 14.4 :
        RB_all = 2
        return RB_all
    
    else :
        RB_all = 1
        return RB_all
    
################### for V2V users ########################
def CQIVUE(SNR) :
    if SNR < -2.5 :
        RB_all = 0
        return RB_all
    
    elif SNR < 0 :
        RB_all = 4
        return RB_all
    
    elif SNR < 1.4 :
        RB_all = 3
        return RB_all

    elif SNR < 3 :
        RB_all = 2
        return RB_all

    else :
        RB_all = 1
        return RB_all

